"""
This is a quick script to help wrangle overlapping csv files generated by the
scraper. In particular, the problem we are looking to solve is this:

    The date ranges in the scraper need to be quite generous, because we want
    to capture new comments on older posts (we can only get comments on posts
    we already have).

    This means for large threads, we get the whole lot again, plus the new
    stuff.

    Most likely, what we want to do is just get the things we haven't got
    before. At the same time, we need some context - it is not much good to
    just take the difference because we need to know what posts the comments are
    on.

This leads to the following solution:
    given two matching csv files, one that contains more data than the other,
    output a new file that contains the symmetric difference of the two files
    AND for each group of comments, includes the post on which they are
    comments.
"""
import argparse
import datetime

import pandas as pd # we definitely want to use something a bit sophisticated


class Op(object):
    """An operation. Should have as class fields:
        name - the short name of the operation
        help - help text for the op (ie. what it does and what arguments it
            takes)
    The init method should take a string of arguments, and the operation
    should be performed by the function call operator (overriding __call__)
    with no arguments.
    It can be assumed that the object will be initialised, used and discarded
    without any real delay."""
    name = "baseop" # put something here to help with debugging
    help = "unimplemented"

    def __call__(self):
        raise NotImplementedError("__call__ has not been overridden")

    @classmethod
    def _binary_args(cls):
        """Sets up argument parser for a binary operation, using the
        name and help defined on the class"""
        parser = argparse.ArgumentParser(description=cls.help)
        parser.add_argument('file_1',
                            help='the first file')
        parser.add_argument('file_2',
                            help='the second file')

        return parser


class SymmetricDifference(Op):
    """Symmetric difference between two files, but with some extra
    context for facebook comments"""
    name = 'symmdiff'
    help = """
    Symmetric difference with context. Will write a file containing
    (at least, see context) all rows that are in one file and not the other.
    needs two file args, and  a switch for whether to provide context.
    Context is as follows:
        for comments, post which the comment was on will always be included,
        regardless of whether it is in both files.
    """
    @classmethod
    def from_args(cls, args):
        """Returns a new SymmetricDeffierence op, from the arguments as
        taken straight from the command line"""
        parser = cls._binary_args()
        # add a switch
        parser.add_argument(
            '--no-context', '-nc',
            action='store_true',
            help='If this flag is present, context information will not be stored')
        # now parse the args
        args = parser.parse_args(args)

        # probably will use this stuff elsewhere
        def date_parser(date_str):
            return datetime.datetime.strptime(date_str, "%d/%m/%Y %I:%M:%S %p")

        # read the files
        print('reading {}'.format(args.file_1))
        data1 = pd.read_csv(args.file_1, encoding='utf-16', index_col='date',
                            parse_dates=True, sep='\t', date_parser=date_parser)
        print('reading {}'.format(args.file_2))
        data2 = pd.read_csv(args.file_2, encoding='utf-16', index_col='date',
                            parse_dates=True, sep='\t', date_parser=date_parser)
        return cls(data1, data2, write_out=True, do_context=not args.no_context)

    def __init__(self, file_1, file_2, write_out=False, do_context=False):
        """Version of init for when no args are present (ie. testing).
        Expects that file_1 and file_2 are data frames already"""
        self.do_context = do_context
        self.data1 = file_1
        self.data2 = file_2
        self.write_out = write_out
        self.outfile = 'output.csv'

    def __call__(self):
        # first up, is there a nice pandas way of doing the symmetric differnce?
        print('doing symmetric difference')
        all_data = pd.concat([self.data1, self.data2])
        grouped = all_data.groupby(list(all_data.columns))
        #print([x for x in grouped.groups])
        # list of unique records
        idx = [x[0] for x in grouped.groups.values() if len(x) == 1]
        if idx: # b/c if not, then totally the same?, return the lot
            # add context here?
            print(len(idx))
            all_data = all_data.loc[idx]
        if self.write_out:
            print('writing results to {}'.format(self.outfile))
            all_data.to_csv(self.outfile, encoding='utf-16', sep='\t',
                            index_label='dates')
        return all_data

########## done with the classes, should put the above in a separate file ######

# this list should contain the class of each op
ALL_OPS = [SymmetricDifference]
# ops by name, for convenience
OPS_DICT = dict([(op.name, op) for op in ALL_OPS])

def setup_main_args():
    """Or rather, arg. Should do submodules etc."""
    parser = argparse.ArgumentParser(
        description="""Help with organising CSV files produced by the
        scraper. Operations are:
            - symmetric difference with context for comments

        more may be added as required.

        This script requires pandas (a python package for wrangling big frames
        of data) to actually do this kind of work reasonably efficiently. The
        easiest way to get pandas on Windows is to install anaconda, a python
        distribution which includes a large number of scientific packages."""
    )

    # first, required, arg is the subcommand
    # then we will delegate.
    # easiest way to do this is with lots of ArgumentParsers and some slicing
    parser.add_argument("operation",
                        help="Which subcommand to run? Options are: {}".format(
                            "\n   ".join([op.name for op in ALL_OPS])
                        ),
                        choices=[op.name for op in ALL_OPS])
    # and we also need the rest
    parser.add_argument("sub_args",
                        help="arguments for the specified subcommand",
                        nargs=argparse.REMAINDER)
    return parser

def get_initialised_op():
    """Returns an op all ready to go. Or exits, with error"""
    # first get the args
    parser = setup_main_args()
    args = parser.parse_args()
    op_cls = OPS_DICT[args.operation]
    return op_cls.from_args(args.sub_args)

def main():
    """Does the thing"""
    op = get_initialised_op()
    op()

if __name__ == '__main__':
    main()
